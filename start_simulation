#!/usr/bin/env python2
"""
Copyright (C) 2017 Jakub Krajniak <jkrajniak@gmail.com>

This file is distributed under free software licence:
you can redistribute it and/or modify it under the terms of the
GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
"""

import espressopp  # NOQA
import math  # NOQA
from mpi4py import MPI
import random
import os
import time

import files_io
import adresslab.tools_sim as tools
import gromacs_topology

import adresslab.tools_backmapping
import adresslab.tools as general_tools

from adresslab.app_args import _args_backmapping as _args

# GROMACS units, kJ/mol K
kb = 0.0083144621

# Storage options

# Mostly you do not need to modify lines below.
def main():  # NOQA
    h5md_group = 'atoms'
    time0 = time.time()
    args = _args().parse_args()

    lj_cutoff = args.lj_cutoff
    cg_cutoff = args.cg_cutoff
    max_cutoff = max([args.lj_cutoff, args.cg_cutoff])

    print('Welcome in AdResSLab!')

    generate_exclusions = args.exclusion_list is None or not os.path.exists(args.exclusion_list)

    input_conf = gromacs_topology.read(args.top, doRegularExcl=generate_exclusions)
    input_gro_conf = files_io.GROFile(args.conf)
    input_gro_conf.read()

    if not generate_exclusions:
        exclusion_file = open(args.exclusion_list, 'r')
        exclusions = [map(int, x.split()) for x in exclusion_file.readlines()]
        print('Read exclusion list from {} (total: {})'.format(args.exclusion_list, len(exclusions)))
        input_conf = input_conf._replace(exclusions=exclusions)
    else:
        exclusion_list_file = 'exclusion_{}.list'.format(args.top.split('.')[0])
        with open(exclusion_list_file, 'w') as fel:
            for p in input_conf.exclusions:
                fel.write('{} {}\n'.format(*p))
        print('Save exclusion list: {} ({})'.format(exclusion_list_file, len(input_conf.exclusions)))

    box = input_gro_conf.box
    print('Setting up simulation...')

    # Tune simulation parameter according to arguments
    integrator_step = args.int_step
    if args.trj_collect > 0:
        integrator_step = min([integrator_step, args.trj_collect])
    k_eq_step = int(args.eq / integrator_step)
    long_step = int(args.long / integrator_step)

    if args.skin:
        skin = args.skin
    else:
        skin = 0.16

    rng_seed = args.rng_seed
    if args.rng_seed == -1:
        rng_seed = random.randint(1, 10000)
        args.rng_seed = rng_seed

    # Initialize RNG
    random.seed(rng_seed)

    # Save the params to the the file.
    _args().save_to_file('{}_{}_params.out'.format(args.output_prefix, rng_seed), args)

    print('Skin: {}'.format(skin))
    print('RNG Seed: {}'.format(rng_seed))
    print('Time step: {}'.format(args.dt))
    print('LJ cutoff: {}'.format(lj_cutoff))
    print('Boltzmann constant = {}'.format(kb))

    system = espressopp.System()
    system.rng = espressopp.esutil.RNG(rng_seed)

    part_prop, all_particles, adress_tuple = adresslab.tools.genParticleList(
        input_conf, input_gro_conf, adress=True, use_charge=True)
    print('Reads {} particles with properties {}'.format(len(all_particles), part_prop))

    if input_conf.charges:
        print('Total charge: {}'.format(sum(input_conf.charges)))

    # Make output from AT particles.
    at_gro_conf = files_io.GROFile.copy(input_gro_conf, [x for p in adress_tuple for x in p[1:]], renumber=True)
    gro_whole = files_io.GROFile.copy(input_gro_conf, [x for p in adress_tuple for x in p], renumber=True)

    # Generate initial velocities, only for CG particles, AT particles will get the CG particle velocity.
    particle_list = []
    index_adrat = part_prop.index('adrat')
    print('Generating velocities from Maxwell-Boltzmann distribution for T={}'.format(args.temperature))
    part_prop.append('v')
    cg_particles = [x for x in all_particles if x.adrat == 0]
    vx, vy, vz = espressopp.tools.velocities.gaussian(
        args.temperature,
        len(cg_particles),
        [x.mass for x in cg_particles],
        kb=kb)
    cg_id = 0
    last_vel = (0.0, 0.0, 0.0)
    last_lambda = 0.0
    last_res_id = -1
    index_lambda = part_prop.index('lambda_adr')
    for p in all_particles:
        t = list(p)
        if p.adrat == 0:  # this is CG particle
            last_vel = (vx[cg_id], vy[cg_id], vz[cg_id])
            cg_id += 1
        if args.nonuniform_lambda and p.res_id != last_res_id:
            last_res_id = p.res_id
            last_lambda = -1.0 * random.uniform(0.0, 10000 * args.alpha)
        if args.nonuniform_lambda:
            t[index_lambda] = last_lambda
        del t[index_adrat]
        t.append(espressopp.Real3D(last_vel))
        particle_list.append(t)

    del part_prop[index_adrat]

    print('Running with box {}'.format(box))

    system.bc = espressopp.bc.OrthorhombicBC(system.rng, box)
    system.skin = skin

    if args.node_grid:
        nodeGrid = map(int, args.node_grid.split(','))
    else:
        nodeGrid = espressopp.tools.decomp.nodeGrid(MPI.COMM_WORLD.size)
    print('Number of nodes {}, node-grid: {}'.format(
        MPI.COMM_WORLD.size, nodeGrid))
    if args.cell_grid:
        cellGrid = map(int, args.cell_grid.split(','))
    else:
        cellGrid = espressopp.tools.decomp.cellGrid(box, nodeGrid, max_cutoff, skin)
    print('Cell grid: {}'.format(cellGrid))


    system.storage = espressopp.storage.DomainDecomposition(system, nodeGrid, cellGrid)

    system.storage.addParticles(map(tuple, particle_list), *part_prop)
    system.storage.decompose()

    vs_list = espressopp.FixedVSList(system.storage)
    vs_list.addTuples(adress_tuple)

    at_particle_group = espressopp.ParticleGroup(system.storage)
    cg_particle_group = espressopp.ParticleGroup(system.storage)
    particle_groups = {'at': at_particle_group, 'cg': cg_particle_group}
    at_particle_ids = set()
    cg_particle_ids = set()
    for a in adress_tuple:
        cg_particle_ids.add(a[0])
        cg_particle_group.add(a[0])
        for at in a[1:]:
            at_particle_group.add(at)
            at_particle_ids.add(at)

    integrator = espressopp.integrator.VelocityVerletHybrid(system, vs_list)
    integrator.dt = args.dt

    system.integrator = integrator

    system.storage.decompose()

    print('Prepared:')
    print('Bonds: {}'.format(sum(len(x) for x in input_conf.bondtypes.values())))
    print('Angles: {}'.format(sum(len(x) for x in input_conf.angletypes.values())))
    print('Dihedrals: {}'.format(sum(len(x) for x in input_conf.dihedraltypes.values())))
    print('Pairs: {}'.format(sum(len(x) for x in input_conf.pairtypes.values())))
    print('CG particles: {}'.format(len(cg_particle_ids)))
    print('AT particles: {}'.format(len(at_particle_ids)))

    print('Setting AdResS module')

    # Define interactions.
    verletlistAT, verletlistCG = adresslab.tools_backmapping.setupSinglePhase(
        system, args, input_conf, at_particle_ids, cg_particle_ids)

    print('Number of interactions: {}'.format(system.getNumberOfInteractions()))

    # Define the thermostat
    temperature = args.temperature * kb
    print('Temperature: {} ({}), gamma: {}'.format(args.temperature, temperature, args.thermostat_gamma))
    print('Thermostat: {}'.format(args.thermostat))
    if args.thermostat == 'lv':
        if args.thermostat_whole:
            print('Enable thermostat on all particles, not only atomistic')
            thermostat = espressopp.integrator.LangevinThermostat(system)
        elif args.thermostat_cg:
            print('Enable thermostat only on CG particles')
            thermostat = espressopp.integrator.LangevinThermostatOnGroup(system, cg_particle_group)
        else:
            thermostat = espressopp.integrator.LangevinThermostatOnGroup(system, at_particle_group)
        thermostat.temperature = temperature
        thermostat.gamma = args.thermostat_gamma
    elif args.thermostat == 'vr':
        thermostat = espressopp.integrator.StochasticVelocityRescaling(system)
        thermostat.temperature = temperature
        thermostat.coupling = args.thermostat_gamma
    integrator.addExtension(thermostat)

    print("Added tuples, decomposing now ...")

    print('Dynamic resolution, rate={}'.format(args.alpha))
    print('CG equilibration for {}'.format(k_eq_step * integrator_step))
    print('Collect trajectory every {} step'.format(k_trj_collect * integrator_step))
    print('Flush trajectory every {} step'.format(k_trj_flush * integrator_step))
    print('Collect energy every {} step'.format(args.energy_collect))
    print('Atomistic long run for {}'.format(long_step * integrator_step))

    system.storage.decompose()

    if args.remove_com > 0:
        print('Removes total velocity of the system every {} steps'.format(args.remove_com))
        total_velocity = espressopp.analysis.CMVelocity(system)
        ext_remove_com = espressopp.integrator.ExtAnalyze(total_velocity, args.remove_com)
        integrator.addExtension(ext_remove_com)

    print('Number of particles: {}'.format(len(particle_list)))

    has_capforce = False
    if args.cap_force:
        has_capforce = True
        print('Define maximum cap-force in the system (max: {})'.format(args.cap_force))
        cap_force = espressopp.integrator.CapForce(system, args.cap_force)
        integrator.addExtension(cap_force)


    print('Finished!')
    print('Total time: {}'.format(time.time() - time0))
    espressopp.tools.analyse.final_info(system, integrator, verletlistAT, time0, time.time())


if __name__ == '__main__':
    main()
